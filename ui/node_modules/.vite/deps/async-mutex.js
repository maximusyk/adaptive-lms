import {
  __awaiter,
  __generator
} from "./chunk-AGADXW7G.js";
import "./chunk-ACCAMVX6.js";

// node_modules/.pnpm/async-mutex@0.3.2/node_modules/async-mutex/es6/errors.js
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");

// node_modules/.pnpm/async-mutex@0.3.2/node_modules/async-mutex/es6/Semaphore.js
var Semaphore = function() {
  function Semaphore2(_maxConcurrency, _cancelError) {
    if (_cancelError === void 0) {
      _cancelError = E_CANCELED;
    }
    this._maxConcurrency = _maxConcurrency;
    this._cancelError = _cancelError;
    this._queue = [];
    this._waiters = [];
    if (_maxConcurrency <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
    this._value = _maxConcurrency;
  }
  Semaphore2.prototype.acquire = function() {
    var _this = this;
    var locked = this.isLocked();
    var ticketPromise = new Promise(function(resolve, reject) {
      return _this._queue.push({ resolve, reject });
    });
    if (!locked)
      this._dispatch();
    return ticketPromise;
  };
  Semaphore2.prototype.runExclusive = function(callback) {
    return __awaiter(this, void 0, void 0, function() {
      var _a, value, release;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this.acquire()];
          case 1:
            _a = _b.sent(), value = _a[0], release = _a[1];
            _b.label = 2;
          case 2:
            _b.trys.push([2, , 4, 5]);
            return [4, callback(value)];
          case 3:
            return [2, _b.sent()];
          case 4:
            release();
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Semaphore2.prototype.waitForUnlock = function() {
    return __awaiter(this, void 0, void 0, function() {
      var waitPromise;
      var _this = this;
      return __generator(this, function(_a) {
        if (!this.isLocked()) {
          return [2, Promise.resolve()];
        }
        waitPromise = new Promise(function(resolve) {
          return _this._waiters.push({ resolve });
        });
        return [2, waitPromise];
      });
    });
  };
  Semaphore2.prototype.isLocked = function() {
    return this._value <= 0;
  };
  Semaphore2.prototype.release = function() {
    if (this._maxConcurrency > 1) {
      throw new Error("this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
    }
    if (this._currentReleaser) {
      var releaser = this._currentReleaser;
      this._currentReleaser = void 0;
      releaser();
    }
  };
  Semaphore2.prototype.cancel = function() {
    var _this = this;
    this._queue.forEach(function(ticket) {
      return ticket.reject(_this._cancelError);
    });
    this._queue = [];
  };
  Semaphore2.prototype._dispatch = function() {
    var _this = this;
    var nextTicket = this._queue.shift();
    if (!nextTicket)
      return;
    var released = false;
    this._currentReleaser = function() {
      if (released)
        return;
      released = true;
      _this._value++;
      _this._resolveWaiters();
      _this._dispatch();
    };
    nextTicket.resolve([this._value--, this._currentReleaser]);
  };
  Semaphore2.prototype._resolveWaiters = function() {
    this._waiters.forEach(function(waiter) {
      return waiter.resolve();
    });
    this._waiters = [];
  };
  return Semaphore2;
}();
var Semaphore_default = Semaphore;

// node_modules/.pnpm/async-mutex@0.3.2/node_modules/async-mutex/es6/Mutex.js
var Mutex = function() {
  function Mutex2(cancelError) {
    this._semaphore = new Semaphore_default(1, cancelError);
  }
  Mutex2.prototype.acquire = function() {
    return __awaiter(this, void 0, void 0, function() {
      var _a, releaser;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this._semaphore.acquire()];
          case 1:
            _a = _b.sent(), releaser = _a[1];
            return [2, releaser];
        }
      });
    });
  };
  Mutex2.prototype.runExclusive = function(callback) {
    return this._semaphore.runExclusive(function() {
      return callback();
    });
  };
  Mutex2.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  };
  Mutex2.prototype.waitForUnlock = function() {
    return this._semaphore.waitForUnlock();
  };
  Mutex2.prototype.release = function() {
    this._semaphore.release();
  };
  Mutex2.prototype.cancel = function() {
    return this._semaphore.cancel();
  };
  return Mutex2;
}();
var Mutex_default = Mutex;

// node_modules/.pnpm/async-mutex@0.3.2/node_modules/async-mutex/es6/withTimeout.js
function withTimeout(sync, timeout, timeoutError) {
  var _this = this;
  if (timeoutError === void 0) {
    timeoutError = E_TIMEOUT;
  }
  return {
    acquire: function() {
      return new Promise(function(resolve, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var isTimeout, handle, ticket, release, e_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                isTimeout = false;
                handle = setTimeout(function() {
                  isTimeout = true;
                  reject(timeoutError);
                }, timeout);
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, sync.acquire()];
              case 2:
                ticket = _a.sent();
                if (isTimeout) {
                  release = Array.isArray(ticket) ? ticket[1] : ticket;
                  release();
                } else {
                  clearTimeout(handle);
                  resolve(ticket);
                }
                return [3, 4];
              case 3:
                e_1 = _a.sent();
                if (!isTimeout) {
                  clearTimeout(handle);
                  reject(e_1);
                }
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      });
    },
    runExclusive: function(callback) {
      return __awaiter(this, void 0, void 0, function() {
        var release, ticket;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              release = function() {
                return void 0;
              };
              _a.label = 1;
            case 1:
              _a.trys.push([1, , 7, 8]);
              return [4, this.acquire()];
            case 2:
              ticket = _a.sent();
              if (!Array.isArray(ticket))
                return [3, 4];
              release = ticket[1];
              return [4, callback(ticket[0])];
            case 3:
              return [2, _a.sent()];
            case 4:
              release = ticket;
              return [4, callback()];
            case 5:
              return [2, _a.sent()];
            case 6:
              return [3, 8];
            case 7:
              release();
              return [7];
            case 8:
              return [2];
          }
        });
      });
    },
    release: function() {
      sync.release();
    },
    cancel: function() {
      return sync.cancel();
    },
    waitForUnlock: function() {
      return sync.waitForUnlock();
    },
    isLocked: function() {
      return sync.isLocked();
    }
  };
}

// node_modules/.pnpm/async-mutex@0.3.2/node_modules/async-mutex/es6/tryAcquire.js
function tryAcquire(sync, alreadyAcquiredError) {
  if (alreadyAcquiredError === void 0) {
    alreadyAcquiredError = E_ALREADY_LOCKED;
  }
  return withTimeout(sync, 0, alreadyAcquiredError);
}
export {
  E_ALREADY_LOCKED,
  E_CANCELED,
  E_TIMEOUT,
  Mutex_default as Mutex,
  Semaphore_default as Semaphore,
  tryAcquire,
  withTimeout
};
//# sourceMappingURL=async-mutex.js.map
